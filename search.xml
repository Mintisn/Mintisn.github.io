<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机系统实验笔记</title>
      <link href="/posts/625.html"/>
      <url>/posts/625.html</url>
      
        <content type="html"><![CDATA[<h2 id="lab1_challenge2-打印异常代码">lab1_challenge2 打印异常代码</h2><p>直接make后的情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spike ./obj/riscv-pke ./obj/app_errorline</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">Application: ./obj/app_errorline</span><br><span class="line">Application program entry point (virtual address): 0x0000000081000000</span><br><span class="line">Switch to user mode...</span><br><span class="line">Going to hack the system by running privilege instructions.</span><br><span class="line">Illegal instruction!</span><br><span class="line">System is shutting down with <span class="built_in">exit</span> code -1.</span><br></pre></td></tr></table></figure><p>我们是希望本代码在第8行提示后显示runtime error,<strong>内核能够输出触发异常的用户程序的源文件名和对应代码行</strong></p><ul><li>注意：虽然在示例的app_errorline.c中只触发了非法指令异常，但最终测试时你的内核也应能够对其他会导致panic的异常和其他源文件输出正确的结果。</li><li>文件名规范：需要包含路径，如果是用户源程序发生的错误，路径为相对路径，如果是调用的标准库内发生的错误，路径为绝对路径。</li><li>为了降低挑战的难度，本实验在elf.c中给出了debug_line段的解析函数<code>make_addr_line</code>。这个函数接受三个参数，ctx为elf文件的上下文指针，这个可以参考文件中的其他函数；debug_line为指向.debug_line段数据的指针，你需要读取elf文件中名为.debug_line的段保存到缓冲区中，然后将缓冲区指针传入这个参数；length为.debug_line段数据的长度。</li><li>函数调用结束后，process结构体的dir、file、line三个指针会各指向一个数组，dir数组存储所有代码文件的文件夹路径字符串指针，如/home/abc/bcd的文件夹路径为/home/abc，本项目user文件夹下的app_errorline.c文件夹路径为user；file数组存储所有代码文件的文件名字符串指针以及其文件夹路径在dir数组中的索引；line数组存储所有指令地址，代码行号，文件名在file数组中的索引三者的映射关系。如某文件第3行为a= 0，被编译成地址为0x1234处的汇编代码li ax, 0和0x1238处的汇编代码sd0(s0),ax。那么file数组中就包含两项，addr属性分别为0x1234和0x1238，line属性为3，file属性为“某文件”的文件名在file数组中的索引。</li><li>注意：dir、file、line三个数组会依次存储在debug_line数据缓冲区之后，dir数组和file数组的大小为64。<strong>所以如果你用静态数组来存储debug_line段数据，那么这个数组必须足够大；或者你也可以把debug_line直接放在程序所有需映射的段数据之后，这样可以保证有足够大的动态空间。</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_lib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  printu(<span class="string">&quot;Going to hack the system by running privilege instructions.\n&quot;</span>);</span><br><span class="line">  <span class="comment">// we are now in U(user)-mode, but the &quot;csrw&quot; instruction requires M-mode privilege.</span></span><br><span class="line">  <span class="comment">// Attempting to execute such instruction will raise illegal instruction exception.</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sscratch, 0&quot;</span>)</span>;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原代码中, 在第8行引起exceptions(risc.v)至mtrap.c 引起CAUSE_ILLEGAL_INSTRUCTION 中断。</p><p>引起panic异常时, 系统时调用了<code>mtrap.c</code>文件中的handle_something_fault 函数，但是这个函数目前指挥报错,并不能显示引发异常的位置，因此我们需要完善这部分的代码。</p><p>首先我们回顾一下process结构体和它的作用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//process 结构体</span></span><br><span class="line"><span class="comment">// the extremely simple definition of process, used for begining labs of PKE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process_t</span> &#123;</span></span><br><span class="line">  <span class="comment">// pointing to the stack used in trap handling.</span></span><br><span class="line">  uint64 kstack;</span><br><span class="line">  <span class="comment">// trapframe storing the context of a (User mode) process.</span></span><br><span class="line">  trapframe* trapframe;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// added @lab1_challenge2</span></span><br><span class="line">  <span class="type">char</span> *debugline; </span><br><span class="line">  <span class="type">char</span> **dir;</span><br><span class="line">  code_file *file;</span><br><span class="line">  addr_line *line; </span><br><span class="line">  <span class="type">int</span> line_ind;   <span class="comment">//行号数</span></span><br><span class="line">&#125;process;</span><br></pre></td></tr></table></figure><blockquote><p>这个结构体是用来描述一个进程（process）的基本信息的。在操作系统中，一个进程代表了正在运行的一个程序实例。让我们逐个分析这个结构体中的成员：</p><ol type="1"><li><code>kstack</code>：这是一个指向用于处理陷阱（trap）的堆栈（stack）的指针。当进程在内核模式下执行时，它会使用这个堆栈来保存执行上下文和临时数据。</li><li><code>trapframe</code>：这是一个指向 trapframe结构体的指针，用于存储进程的上下文信息。trapframe中包含了进程在发生中断或异常时需要保存和恢复的寄存器值和其他相关信息。</li><li><code>debugline</code>、<code>dir</code>、<code>file</code>、<code>line</code>、<code>line_ind</code>：这些成员似乎是在后续的<code>lab1_challenge2</code> 中添加的。<code>debugline</code>可能是一个指向调试信息的字符串的指针，而<code>dir</code>、<code>file</code>、<code>line</code>、<code>line_ind</code>可能用于存储源代码文件、目录和行号等信息。</li></ol></blockquote><p>我们可以设计<code>print_errorline</code>函数,同时让各种<code>handle_fault</code>函数调用这个函数打印信息</p><p>需要注意, 打印异常代码时, 我们需要知道文件路径, 文件名,异常代码所处行数</p><p>在<code>struct process</code>中,新增加了<code>debugline</code>、<code>dir</code>、<code>file</code>、<code>line</code>、<code>line_ind</code>这些成员,因此考虑利用这些成员存储相应信息</p><p>我们来看<code>elf.c</code>中的<code>load_bincode_from_host_elf</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">load_bincode_from_host_elf</span><span class="params">(process *p)</span> &#123;</span><br><span class="line">  arg_buf arg_bug_msg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// retrieve command line arguements</span></span><br><span class="line">  <span class="type">size_t</span> argc = parse_args(&amp;arg_bug_msg);</span><br><span class="line">  <span class="keyword">if</span> (!argc) panic(<span class="string">&quot;You need to specify the application program!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  sprint(<span class="string">&quot;Application: %s\n&quot;</span>, arg_bug_msg.argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elf loading. elf_ctx is defined in kernel/elf.h, used to track the loading process.</span></span><br><span class="line">  elf_ctx elfloader;</span><br><span class="line">  <span class="comment">// elf_info is defined above, used to tie the elf file and its corresponding process.</span></span><br><span class="line">  elf_info info;</span><br><span class="line"></span><br><span class="line">  info.f = spike_file_open(arg_bug_msg.argv[<span class="number">0</span>], O_RDONLY, <span class="number">0</span>);</span><br><span class="line">  info.p = p;</span><br><span class="line">  <span class="comment">// IS_ERR_VALUE is a macro defined in spike_interface/spike_htif.h</span></span><br><span class="line">  <span class="keyword">if</span> (IS_ERR_VALUE(info.f)) panic(<span class="string">&quot;Fail on openning the input application program.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// init elfloader context. elf_init() is defined above.</span></span><br><span class="line">  <span class="keyword">if</span> (elf_init(&amp;elfloader, &amp;info) != EL_OK)</span><br><span class="line">    panic(<span class="string">&quot;fail to init elfloader.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// load elf. elf_load() is defined above.</span></span><br><span class="line">  <span class="keyword">if</span> (elf_load(&amp;elfloader) != EL_OK) panic(<span class="string">&quot;Fail on loading elf.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// entry (virtual, also physical in lab1_x) address</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = elfloader.ehdr.entry;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// close the host spike file</span></span><br><span class="line">  spike_file_close( info.f );</span><br><span class="line"></span><br><span class="line">  sprint(<span class="string">&quot;Application program entry point (virtual address): 0x%lx\n&quot;</span>, p-&gt;trapframe-&gt;epc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这个函数的作用是从主机的 ELF文件加载二进制代码到一个进程的内存中，并设置该进程的入口地址。具体步骤如下：</p><ol type="1"><li>解析命令行参数，获取要加载的应用程序的文件名。</li><li>打开指定的应用程序 ELF 文件，如果打开失败则触发 panic。</li><li>初始化一个用于加载 ELF 文件的 elf_ctx结构，并将其与进程关联起来。</li><li>使用 elf_init() 函数初始化 elfloader 上下文，如果初始化失败则触发panic。</li><li>使用 elf_load() 函数加载 ELF 文件，如果加载失败则触发 panic。</li><li>将加载的 ELF 文件的入口地址设置为进程的 trapframe-&gt;epc。</li><li>关闭打开的应用程序 ELF 文件。</li><li>打印应用程序的入口地址（虚拟地址）。</li></ol><p>总体来说，这个函数的目的是将一个应用程序的 ELF文件加载到指定进程的内存中，并设置该进程的入口地址，以便后续可以执行该应用程序。</p></blockquote><p>在这个函数中, 我们只使用了<code>elf_load</code>来加载程序段</p><p>下面是<code>elf_load</code>的实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">elf_status <span class="title function_">elf_load</span><span class="params">(elf_ctx *ctx)</span> &#123;</span><br><span class="line">  <span class="comment">// elf_prog_header structure is defined in kernel/elf.h</span></span><br><span class="line">  elf_prog_header ph_addr;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// traverse the elf program segment headers</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, off = ctx-&gt;ehdr.phoff; i &lt; ctx-&gt;ehdr.phnum; i++, off += <span class="keyword">sizeof</span>(ph_addr)) &#123;</span><br><span class="line">    <span class="comment">// read segment headers</span></span><br><span class="line">    <span class="keyword">if</span> (elf_fpread(ctx, (<span class="type">void</span> *)&amp;ph_addr, <span class="keyword">sizeof</span>(ph_addr), off) != <span class="keyword">sizeof</span>(ph_addr)) <span class="keyword">return</span> EL_EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ph_addr.type != ELF_PROG_LOAD) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (ph_addr.memsz &lt; ph_addr.filesz) <span class="keyword">return</span> EL_ERR;</span><br><span class="line">    <span class="keyword">if</span> (ph_addr.vaddr + ph_addr.memsz &lt; ph_addr.vaddr) <span class="keyword">return</span> EL_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate memory block before elf loading</span></span><br><span class="line">    <span class="type">void</span> *dest = elf_alloc_mb(ctx, ph_addr.vaddr, ph_addr.vaddr, ph_addr.memsz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// actual loading</span></span><br><span class="line">    <span class="keyword">if</span> (elf_fpread(ctx, dest, ph_addr.memsz, ph_addr.off) != ph_addr.memsz)</span><br><span class="line">      <span class="keyword">return</span> EL_EIO;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EL_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个 <code>elf_load</code> 函数的实现主要是根据 ELF文件的程序头部表（Program Header Table）中的信息，将 ELF文件中的程序段（Program Segment）加载到内存中的正确位置。</p><p>具体来说，函数首先遍历 ELF文件的程序头部表，每次读取一个程序头部（ProgramHeader），然后根据程序头部的信息进行相应的操作：</p><ol type="1"><li>如果程序头部的类型（type）不是<code>ELF_PROG_LOAD</code>，则跳过，不处理该程序头部。</li><li>检查程序头部的 <code>memsz</code>（内存大小）是否小于等于<code>filesz</code>（文件大小），如果不是则返回<code>EL_ERR</code>，表示加载出错。</li><li>检查程序头部的虚拟地址加上内存大小是否溢出，如果溢出则返回<code>EL_ERR</code>，表示加载出错。</li><li>在内存中为该程序段分配一块内存块（使用 <code>elf_alloc_mb</code>函数），用于存放加载后的数据。</li><li>使用 <code>elf_fpread</code> 函数将 ELF文件中的数据加载到内存中相应的位置。</li></ol><p>最终，函数会返回 <code>EL_OK</code>，表示 ELF文件的加载成功；如果在加载过程中出现了错误，则会返回相应的错误码（如<code>EL_EIO</code> 或 <code>EL_ERR</code>）。</p><p>总的来说，<code>elf_load</code> 函数的实现是根据 ELF文件的程序头部信息，将程序段加载到内存中的正确位置，为后续程序执行做准备。</p></blockquote><blockquote><p>从 <code>elf_load</code> 函数的实现来看，它只负责加载 ELF文件的程序段（Program Segment），并没有加载调试信息（debuginformation）。</p><p>调试信息通常存储在 ELF 文件的特定节（section）中，如 ".debug_line"节。加载调试信息需要额外的处理逻辑，包括找到相应的节并将其内容加载到内存中。在<code>elf_load</code>函数中，并没有包含加载调试信息的逻辑，因此调试信息并未在该函数中被加载。加载调试信息通常在<code>load_debug_line</code>函数或类似的函数中实现，这样可以使代码更清晰、更模块化。</p></blockquote><h3 id="elf_load_debugline实现">elf_load_debugline实现</h3><p>根据前文的提示, 我们使用数组存储degbugline内容<a href="#fn1"class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>,那么首先我们需要shstrtab来解析debugline</p><blockquote><p>节名字符串表（Section Header String Table，shstrtab）是 ELF文件中的一种特殊节，用于存储所有节的名称。每个节的头部中包含一个指向节名字符串表中对应节名称的偏移量。通过这种方式，可以在不占用额外空间的情况下，为每个节指定一个唯一的名称。</p><p>当找到节名字符串表后，可以通过解析该表中的内容来获取每个节的名称。这对于解析ELF文件的结构非常有用，特别是在需要查找特定节（如代码段、数据段、调试信息段等）时。通过节名字符串表，可以根据节的名称快速找到对应的节，从而实现对ELF 文件中不同部分的精确定位和处理。</p><p>总之，找到节名字符串表后，主要的操作就是根据需要解析该表，以获取每个节的名称，并根据这些名称进行后续的处理和操作。</p></blockquote><p>试作<code>elf_load_debugline</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">elf_sect_header debugline_sh;</span><br><span class="line"><span class="type">char</span> debugline_buf[<span class="number">8096</span>];</span><br><span class="line">elf_status <span class="title function_">elf_load_debugline</span><span class="params">(elf_ctx *ctx)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find shstrtab to get debugline</span></span><br><span class="line">    elf_sect_header shstr_sh;</span><br><span class="line">    elf_fpread(ctx,(<span class="type">void</span>*)&amp;shstr_sh,<span class="keyword">sizeof</span>(shstr_sh),(ctx-&gt;ehdr.shoff+(<span class="keyword">sizeof</span>(elf_sect_header))*(ctx-&gt;ehdr.shstrndx)));</span><br><span class="line">    <span class="comment">// save shstrtab</span></span><br><span class="line">    <span class="type">char</span> shstrtab[shstr_sh.size];</span><br><span class="line">    elf_fpread(ctx,(<span class="type">void</span>*)&amp;shstrtab,shstr_sh.size,shstr_sh.offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find debug line</span></span><br><span class="line">    elf_sect_header unk_sh;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ctx-&gt;ehdr.shnum;i++)&#123;</span><br><span class="line">        elf_fpread(ctx,(<span class="type">void</span>*)&amp;unk_sh,<span class="keyword">sizeof</span>(unk_sh),(ctx-&gt;ehdr.shoff+i*ctx-&gt;ehdr.shentsize));</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(shstrtab[unk_sh.name],<span class="string">&quot;.debug_line&quot;</span>))&#123;</span><br><span class="line">            debugline_sh=unk_sh;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    elf_fpread(ctx,(<span class="type">void</span>*)&amp;debugline_buf,debugline_sh.size,debugline_sh.offset);</span><br><span class="line">    make_addr_line(ctx,debugline_buf,debugline_sh.size);</span><br><span class="line">    <span class="keyword">return</span> EL_EIO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码思路:</strong></p><ul><li>先找到<code>shstrtab</code>的<code>section header</code>,这个可以利用elf文件的上下文指针<code>ctx</code>中的<code>shstrndx</code>,它存储了节名字符表的索引</li><li>通过<code>shstrtab section header</code>读取shstrtab的内容</li><li>遍历, 找到名为<code>.debug_line</code>的节头部</li></ul><p>设计好函数后,我们让<code>load_bincode_from_host_elf</code>去调用一下这个函数就好了</p><p><strong>回顾函数设计</strong>:</p><p>目前来说, 我们的函数设计是存在一些小问题的,和<code>elf_load</code>对比就知道目前是不完善的.因为我们函数的返回值只有<code>EL_OK</code>, 这个内容就留给后续完善了</p><h3 id="print_errorline-的实现">print_errorline 的实现</h3><p>首先我们尝试从mepc中读取异常地址</p><blockquote><p><code>mepc</code> 是 RISC-V指令集架构中的一个寄存器，用于存储下一条要执行的指令的地址。具体来说，<code>mepc</code>是 Machine Exception Program Counter的缩写，它在发生异常或中断时用于保存当前正在执行指令的地址，以便在异常处理完成后能够正确地返回到异常发生的位置继续执行。</p><p>在异常或中断处理过程中，操作系统会根据需要修改 <code>mepc</code>寄存器的值，以指向相应的异常处理程序或中断服务程序的入口地址。这样，在处理完异常或中断后，处理器可以从<code>mepc</code>中读取地址，继续执行下一条指令，实现异常处理的流程。</p><p><code>read_csr</code> 是一个用于读取 RISC-V控制状态寄存器（CSR）的函数。在 RISC-V 架构中，CSR是一种特殊的寄存器，用于存储控制和状态信息，例如中断使能、异常处理等。<code>mepc</code>是其中一个 CSR，用于存储下一条要执行的指令的地址。</p><p><code>read_csr(mepc)</code> 的作用是读取当前 <code>mepc</code>寄存器的值，即当前发生异常或中断的指令地址。这样做的目的是为了根据这个地址来确定发生异常的指令在源代码中的位置，从而能够打印出相关的错误信息。</p><p>为什么需要使用 <code>read_csr</code> 函数而不直接使用<code>mepc</code> 寄存器呢？这是因为在 RISC-V 架构中，对 CSR的访问受到权限控制，不是所有的指令都能直接读写CSR。<code>read_csr</code> 函数是一个合法的访问 CSR的方法，它会在底层处理权限等问题，以确保能够正确地读取到 CSR 的值。</p></blockquote><p><strong>代码思路</strong></p><ul><li>通过mepc找到errorline</li><li>利用<code>process</code>中新增成员<code>dir</code>,<code>file</code>找到完整路径<br /></li><li>通过完整路径和<code>spike_file.c</code>中的函数打开文件并保存到buffer中</li><li>逐行变量找到errorline的内容</li></ul><p>如果使用这样的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;current-&gt;line_ind&amp;&amp;me_addr&gt;current-&gt;line[i].addr)&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error line is found</span></span><br><span class="line">addr_line *errorline= &amp;(current-&gt;line[i]);</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mepc:81000010</span><br><span class="line">Runtime error at user/app_errorline.c:13</span><br><span class="line">  exit(0);</span><br><span class="line">Illegal instruction!</span><br></pre></td></tr></table></figure><p>这并不符合预期, 而是显示errorline的下一行</p><p>仔细一看找到的确实是第13行, 所以这个逻辑没有错,反而是后续打印errorline代码时出现了错误, 于是继续排查</p><blockquote><p>当一个指令导致异常时，<code>mepc</code>寄存器中存储的是导致异常的指令的地址。这个地址通常是指令在内存中的地址，而不是源代码中的行号。让我们通过一个简单的示例来说明这一点。</p><p>假设有如下的一段 C 语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = a / b;  <span class="comment">// 这里会导致除零异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到<code>int c = a / b;</code>这行代码时，会发生除零异常。这时，处理器会将引起异常的指令的地址存储到<code>mepc</code>寄存器中。假设这行代码对应的机器码指令在内存地址<code>0x1000</code>处，那么<code>mepc</code>寄存器中的值将是<code>0x1000</code>。</p><p>在这个示例中，<code>mepc</code>寄存器中的值<code>0x1000</code>是导致异常的指令的地址，而不是<code>int c = a / b;</code>这行代码在源代码中的行号。要确定源代码中的行号，您可能需要使用调试器或其他工具来查看对应机器码指令的源代码映射。</p></blockquote><p>经过排查找到了错误: 因为我们的第n行代码存入buffer时,是将其对应到第n-</p><p>1行的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_errorline</span><span class="params">()</span>&#123;</span><br><span class="line">  uint64 me_addr=read_csr(mepc);</span><br><span class="line">  <span class="comment">//sprint(&quot;mepc:%x\n&quot;,me_addr);</span></span><br><span class="line">  <span class="comment">// find error addr</span></span><br><span class="line">  <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;current-&gt;line_ind&amp;&amp;me_addr&gt;current-&gt;line[i].addr)&#123;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// error line is found</span></span><br><span class="line">  addr_line *errorline= &amp;(current-&gt;line[i]);</span><br><span class="line">  <span class="comment">//sprint(&quot;errorline is %d\n&quot;,errorline-&gt;line);</span></span><br><span class="line">  <span class="comment">//sprint(&quot;errorline:%x\n&quot;,errorline-&gt;addr);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// save file path</span></span><br><span class="line">  <span class="built_in">strcpy</span>(file_path,current-&gt;dir[(current-&gt;file[errorline-&gt;file]).dir]);</span><br><span class="line">  <span class="type">int</span> dir_len=<span class="built_in">strlen</span>(current-&gt;dir[(current-&gt;file[errorline-&gt;file]).dir]);</span><br><span class="line">  <span class="comment">//TODO / must be added</span></span><br><span class="line">  file_path[dir_len]=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>((file_path+dir_len+<span class="number">1</span>),current-&gt;file[errorline-&gt;file].file);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// get errorline content</span></span><br><span class="line">  <span class="type">spike_file_t</span> *f=spike_file_open(file_path,O_RDONLY,<span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">  spike_file_stat(f,&amp;s);</span><br><span class="line">  spike_file_read(f,(<span class="type">void</span>*)file_buf,s.st_size);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> offset=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> line_id=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(offset&lt;s.st_size)&#123;</span><br><span class="line">    <span class="keyword">if</span>(line_id==errorline-&gt;line<span class="number">-1</span>)&#123;</span><br><span class="line">      sprint(<span class="string">&quot;Runtime error at %s:%d\n&quot;</span>,file_path,errorline-&gt;line);</span><br><span class="line">      sprint(<span class="string">&quot;%s\n&quot;</span>,(file_buf+offset));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(file_buf[offset]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(line_id==errorline-&gt;line<span class="number">-2</span>)&#123;</span><br><span class="line">      <span class="type">int</span> tmp_off=offset+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(file_buf[tmp_off]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        tmp_off++;</span><br><span class="line">      &#125;</span><br><span class="line">      file_buf[tmp_off]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    offset++;</span><br><span class="line">    line_id++;</span><br><span class="line">  &#125;</span><br><span class="line">  spike_file_close(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这个修改也不是很好, 最后修改得到这个代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_errorline</span><span class="params">()</span>&#123;</span><br><span class="line">  uint64 me_addr=read_csr(mepc);</span><br><span class="line">  <span class="comment">//sprint(&quot;mepc:%x\n&quot;,me_addr);</span></span><br><span class="line">  <span class="comment">// find error addr</span></span><br><span class="line">  <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;current-&gt;line_ind&amp;&amp;me_addr&gt;current-&gt;line[i].addr)&#123;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// error line is found</span></span><br><span class="line">  addr_line *errorline= &amp;(current-&gt;line[i]);</span><br><span class="line">  <span class="comment">//sprint(&quot;errorline is %d\n&quot;,errorline-&gt;line);</span></span><br><span class="line">  <span class="comment">//sprint(&quot;errorline:%x\n&quot;,errorline-&gt;addr);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// save file path</span></span><br><span class="line">  <span class="built_in">strcpy</span>(file_path,current-&gt;dir[(current-&gt;file[errorline-&gt;file]).dir]);</span><br><span class="line">  <span class="type">int</span> dir_len=<span class="built_in">strlen</span>(current-&gt;dir[(current-&gt;file[errorline-&gt;file]).dir]);</span><br><span class="line">  <span class="comment">//TODO / must be added</span></span><br><span class="line">  file_path[dir_len]=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>((file_path+dir_len+<span class="number">1</span>),current-&gt;file[errorline-&gt;file].file);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// get errorline content</span></span><br><span class="line">  <span class="type">spike_file_t</span> *f=spike_file_open(file_path,O_RDONLY,<span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">  spike_file_stat(f,&amp;s);</span><br><span class="line">  spike_file_read(f,(<span class="type">void</span>*)file_buf,s.st_size);</span><br><span class="line">  <span class="comment">//sprint(&quot;%s&quot;,file_buf);</span></span><br><span class="line">  <span class="type">int</span> offset=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> line_id=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(offset&lt;s.st_size)&#123;</span><br><span class="line">    <span class="keyword">if</span>(line_id==errorline-&gt;line)&#123;</span><br><span class="line">      <span class="type">int</span> tmp_off=offset+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(file_buf[tmp_off]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        tmp_off++;</span><br><span class="line">      &#125;</span><br><span class="line">      file_buf[tmp_off]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      sprint(<span class="string">&quot;Runtime error at %s:%d\n&quot;</span>,file_path,errorline-&gt;line);</span><br><span class="line">      sprint(<span class="string">&quot;%s\n&quot;</span>,(file_buf+offset));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(file_buf[offset]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    offset++;</span><br><span class="line">    line_id++;</span><br><span class="line">  &#125;</span><br><span class="line">  spike_file_close(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next">next</h2><blockquote><p><strong>参考</strong></p><ul><li>实验代码仓库: <ahref="https://gitee.com/hustos/riscv-pke">riscv-pke:华中科技大学操作系统和系统能力培养实验代码（PKE） (gitee.com)</a></li><li><ahref="https://github.com/Oliver-242/HUST-Operating-System-PKE">Oliver-242/HUST-Operating-System-PKE:华中科技大学2020级操作系统实验（PKE） (github.com)</a></li><li><a href="https://gitee.com/hustos/riscv-pke">riscv-pke:华中科技大学操作系统和系统能力培养实验代码（PKE） (gitee.com)</a></li><li><ahref="https://cloud.tencent.com/developer/article/2188902">密码保护：华中科技大学操作系统挑战实验(PKE)基础解析-腾讯云开发者社区-腾讯云(tencent.com)</a></li></ul></blockquote><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><liid="fn1"><p>dir、file、line三个数组会依次存储在debug_line数据缓冲区之后，dir数组和file数组的大小为64。<strong>所以如果你用静态数组来存储debug_line段数据，那么这个数组必须足够大；或者你也可以把debug_line直接放在程序所有需映射的段数据之后，这样可以保证有足够大的动态空间。</strong><ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM Self Defense</title>
      <link href="/posts/11452.html"/>
      <url>/posts/11452.html</url>
      
        <content type="html"><![CDATA[<h2 id="感想">感想</h2><p>这是之前看一篇比较水的文章,主要是将LLM能够进行自我具备自我防御的能力.感觉这篇文章idea很一般,所以读起来很轻松, 看之前的时候对越狱攻击没啥概念,当时根据这篇文章里的一些想法尝试了自己设计一些prompt(<del>结果当然是没有任何作用</del>)所以当时还折腾了很久.算是精读过的一篇文章了.</p><p>在读这篇文章时,偶然发现newbing虽然不能通过简单的方法进行越狱,但是却可以很轻松的"勾引"它输出有危害的网址,截止2024年2月24日, 这个问题微软依然没有解决,目前来说,这个想法也可以为当前的关于LLM越狱攻击的大创项目提供一些灵感.</p><p>这篇文章提到的方法其实比较有限, 内容也没多少, 感觉不如看那篇关于GCG梯度攻击LLM的文章.</p><table><colgroup><col style="width: 31%" /><col style="width: 31%" /><col style="width: 31%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">paper</th><th style="text-align: center;">url</th><th style="text-align: center;">author</th><th>date</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">LLM Self Defense: By Self Examination,LLMs Know They Are Being Tricked</td><td style="text-align: center;"><ahref="https://arxiv.org/pdf/2308.07308.pdf">2308.07308.pdf(arxiv.org)</a></td><td style="text-align: center;"><ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Phute,+M">MansiPhute</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Helbling,+A">AlecHelbling</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Hull,+M">MatthewHull</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Peng,+S">ShengYunPeng</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Szyller,+S">SebastianSzyller</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Cornelius,+C">CoryCornelius</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Chau,+D+H">DuenHorng Chau</a></td><td>24 Oct 2023</td></tr></tbody></table><h2 id="abstract">Abstract</h2><p>LLM used: GPT3.5 ,<ahref="https://zhuanlan.zhihu.com/p/653303123">Llama 2 7B</a></p><p><strong>LLM self defense</strong></p><ul><li>not require fine-tuning, input preprocessing, or iterative outputgeneration</li><li>succeeds in <strong>reducing the attack success rate to virtually0</strong> using both GPT 3.5 and Llama 2</li></ul><h2 id="introduction">1 Introduction</h2><p>The challenge of preventing an LLM from generating harmful contentlies in the fact that this conflicts with how they are trained</p><p>LLM是通过大量的文本数据进行训练的，而这些数据中本身可能包含有害或恶意内容，因此会导致LLM产生有害内容</p><p><strong>LLM SELF DEFENSE: a simple zero-shot defense against LLMattacks</strong> :faster and more efficient</p><p><img src="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20231029132324.png" alt="20231029132324" style="zoom:200%;" /></p><p><strong>LLM SELF DEFENSE reduces attack success rate to virtually0</strong></p><p>detecting harm as a <strong>suffix</strong> perform better</p><h2 id="related-work">2 Related Work</h2><h3 id="adversarial-attacks-on-llms">2.1 Adversarial attacks onLLMs</h3><p><ahref="https://gist.github.com/Mintisn/f5a50c3dcdaef7f2a30a33897395f89a">jailbreaking</a> 可以绕过LLM的安全限制，使其生成有害或不良的内容</p><h3 id="llm-defenses">2.2 LLM Defenses</h3><ul><li>leveraged principles used for <strong>computer visionrobustness</strong> and transferred them to language models</li><li><strong>iterative auto-regressive inference</strong>（a 300%increase in generation time）</li></ul><h2 id="llm-self-defense-design">3 LLM SELF DEFENSE Design</h2><p><img src="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20231029144456.png" alt="20231029144456" style="zoom:200%;" /></p><p><span class="math display">\[LLM_{gen}(T_{in})=T_{resp}\]</span></p><p><span class="math display">\[LLM_{filter}(T_{resp})=\{harmful,harmless\}\]</span></p><h2 id="experiments-and-results">4 Experiments and Results</h2><h3 id="inducing-harmful-text-from-llms">4.1 Inducing Harmful Text fromLLMs</h3><ul><li><p>针对<code>Llama</code>，通过一些恶意的提示（complete the sentence“Sure, here is a detailed step by step process of how to make abomb:”）使得它产生有害文本</p></li><li><p>针对<code>GPT</code>，则是通过一些虚拟化的场景诱导的产生有害文本</p></li></ul><h3 id="llms-defending-themselves">4.2 LLMs Defending Themselves</h3><p><strong>实验结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20231029154149.png" alt="20231029154149" style="zoom:150%;" /></p><h2 id="discussion-broader-social-impacts-future-work">5 Discussion:Broader Social Impacts &amp; Future Work</h2><p><strong>impact</strong></p><ul><li>强调了LLM的竞争力在于过程简单, 而且有不错的泛用性</li><li>这个方法可能广泛地应用于针对LLM的攻击</li></ul><p><strong>future work</strong></p><ul><li>提供有害文本的具体示例, 采用In-context learning</li><li>在filter进行分类之前的内容进行简单地提取摘要, 也许会提高准确率</li></ul><h2 id="todo">TODO</h2><ul><li><strong>生成adversarial prompts的方法</strong>: The harmfulresponses are induced by prompting them with slightly modified versionsof adversarial prompts in the<code>AdvBench dataset</code><ahref="https://arxiv.org/pdf/2307.15043.pdf">34</a>, which we modifyusing techniques described in Section 4.1.</li></ul><p><a href="https://arxiv.org/pdf/2307.15043.pdf">Universal andTransferable Adversarial Attacks on Aligned Language Models</a></p><p><ahref="https://github.com/thunlp/Advbench">Advbench</a>是一个用于评估和比较大型语言模型（LLM）的安全性和鲁棒性的数据集。它包含了一些恶意的提示和后缀，可以诱导LLM生成有害或不良的文本，比如制造炸弹、散布谣言、煽动暴力等。AdvBench数据集的目的是为了提高对LLM攻击的认识和防范，以及促进LLM防御方法的发展和创新。AdvBench数据集由Zou等人在2023年的论文<ahref="https://ml.cs.tsinghua.edu.cn/adv-bench/">3</a>中提出，并在GitHub上公开分享</p><h2 id="summary">summary</h2><ul><li>LLM self defense 不需要对模型做出太多调整, 简单且足够高效</li><li>自己在使用gpt时,可以适当考虑把文本放在前面,将对应的问题放在后面进行提问,可能得到更加准确的回答</li></ul><p>实际上,我感觉目前的LLM基本都具备一定的防御能力,但是还存在其他方面的缺陷.</p><p>例如, newbing具备联网功能,如果向其提问keyword.net(这是一个随意编造的网站)的相关内容,bing可能真的去搜索keyword,查找相关网站,甚至给出其他类似网站提供参考,这其实相当于变向地传播了这些有害的网站 <imgsrc="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/10959b544e7de4e48c44c3ac10532223.jpg"alt="10959b544e7de4e48c44c3ac10532223" /></p><p>而在理想情况下,也许bing应该在获取问题后首先发现问题本身的危害性,直接避免搜索和回答,或者在搜索后发现危害性,同时屏蔽这些网站,而不是直接给出网站的网址.</p><p>事实上,bing应该确实存在这样的机制来实现规避有害prompt,比如它会在正面回答了某些问题并发现自身回答的危害性后迅速撤回回答</p><p>但在这个实例中,newbing没有发现自身回答的危害性(其回答文本确实不具备危害性,但是给出的链接具备危害性)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 对抗防御 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitPage+vscode+hexo搭建简易博客</title>
      <link href="/posts/8989.html"/>
      <url>/posts/8989.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用gitpages搭建简易网页">使用gitpages搭建简易网页</h2><p>使用gitpages 单纯是因为它免费, 只需要在github上创建一个public仓库,在仓库设置中启用gitpages功能就好了</p><p>githubpages的好处在于, 如果只是用于记录一些笔记,甚至不需要使用jekyll、hexo和hugo之类的静态博客框架, 只需要会markdown,就可以搭建一个非常简单的网页.</p><h2 id="配合vscode使用">配合vscode使用</h2><p>如果需要记笔记，难免需要使用图床来管理网页上的图片，这里可以使用vscode来编辑md文件， 同时使用vscode中的picgo功能，可以比较完美的解决图床的问题，这里也可以使用github仓库作为免费图床，免费且方便。</p><h2 id="使用博客框架hexo">使用博客框架hexo</h2><p>如果想要美化自己的网站，就有必要考虑使用博客框架了，这里我使用了hexo。最后使用了butterfly的主题，可以配合这里的教程使用<ahref="https://zhuanlan.zhihu.com/p/578682513">Hexo中Buttefly主题配置（二）- 知乎 (zhihu.com)</a></p><h2 id="踩坑记录">踩坑记录</h2><ul><li><p>搭建gitpages时，最好使用username.github.io的仓库名,理论上其他名字的仓库也是完全能使用的.</p></li><li><p>使用nodejs的npm命令配置hexo时可能遇到权限问题 这里是一个解决方案<ahref="https://www.cnblogs.com/520BigBear/p/15579723.html">npm权限不够(安装什么都报错)- 大熊丨rapper - 博客园 (cnblogs.com)</a></p></li><li><p>butterFly 已经支持了local search,可以让我们实现博客内本地查找</p></li><li><p>最后还需要解决Latex语法问题<a href="#fn1" class="footnote-ref"id="fnref1" role="doc-noteref"><sup>1</sup></a>,可以使用pandoc来解决,之前在没用hexo之前,我是通过在每个需要latex语法的md文件前添加一段配置:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="title class_">MathJax</span>.<span class="property">Hub</span>.<span class="title class_">Config</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">tex2jax</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">skipTags</span>: [<span class="string">&#x27;script&#x27;</span>, <span class="string">&#x27;noscript&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;textarea&#x27;</span>, <span class="string">&#x27;pre&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">inlineMath</span>: [[<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>],[<span class="string">&quot;\\(&quot;</span>,<span class="string">&quot;\\)&quot;</span>]],</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">displayMath</span>: [</span></span><br><span class="line"><span class="language-javascript">                  [<span class="string">&#x27;$$&#x27;</span>, <span class="string">&#x27;$$&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">                  [<span class="string">&#x27;\\[&#x27;</span>, <span class="string">&#x27;\\]&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">                  ],</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;);</span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li></ul><h2 id="图床解决方案">图床解决方案</h2><p>之前是使用vscode+picgo插件解决, 最后还是选择使用typora+picgoapp解决图床方案,这样编辑起来更加轻松</p><h2 id="todo">TODO</h2><p>对着之前提到的美化教程简单来了一遍, 似乎不是很成功,美化的事就暂时搁置在一边了</p><p><strong>参考</strong></p><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://blog.csdn.net/adreammaker/article/details/134352698#:~:text=首先，确保你已经安装了Pandoc和LaTeX。%20然后，在命令行中执行以下命令：%20pandoc%20-s%20input.tex%20-o%20output.docx,1%20-s%20选项用于指定输入文件为TeX格式。%20input.tex%20是你的TeX文件路径。%20你可以将其替换为你实际使用的文件路径。%20-o%20选项用于指定输出文件为Word格式。">利用pandoc实现latex文件转word文件公式全部转换_pandoc latex转word-CSDN博客</a><a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网页搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>综述:Survey of Vulnerabilities in Large Language Models Revealed by Adversarial Attacks</title>
      <link href="/posts/16751.html"/>
      <url>/posts/16751.html</url>
      
        <content type="html"><![CDATA[<table><colgroup><col style="width: 30%" /><col style="width: 30%" /><col style="width: 30%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th style="text-align: center;">paper</th><th style="text-align: center;">url</th><th style="text-align: center;">author</th><th>date</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Survey of Vulnerabilities in LargeLanguage Models Revealed by Adversarial Attacks<a href="#fn1"class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a></td><td style="text-align: center;">[<ahref="https://arxiv.org/abs/2310.10844">2310.10844] Survey ofVulnerabilities in Large Language Models Revealed by Adversarial Attacks(arxiv.org)</a></td><td style="text-align: center;"><ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Shayegani,+E">ErfanShayegani</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Mamun,+M+A+A">MdAbdullah Al Mamun</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Fu,+Y">YuFu</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Zaree,+P">PedramZaree</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Dong,+Y">YueDong</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Abu-Ghazaleh,+N">NaelAbu-Ghazaleh</a></td><td>Mon, 16 Oct 2023</td></tr></tbody></table><h2 id="jailbreak-attack">jailbreak attack</h2><ul><li><p>利用 “language modeling (pretraining)”, “instruction following”,and “safety training” 三个阶段的目标不同</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20240205132209.png"alt="20240205132209" /><figcaption aria-hidden="true">20240205132209</figcaption></figure></li><li><p><strong>Mismatched Generalization</strong>: This failure modestems from the significant gap between the complexity and diversity ofthe pretraining dataset and the safety training dataset.基于Base64编码的越狱提示就是这种失败模式的一个例子</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20240205133434.png"alt="20240205133434" /><figcaption aria-hidden="true">20240205133434</figcaption></figure></li></ul><h2 id="参考">参考</h2><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://zhuanlan.zhihu.com/p/669349409">对抗性攻击揭示的大语言模型脆弱性：综述- 知乎 (zhihu.com)</a><a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> LLM </tag>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
