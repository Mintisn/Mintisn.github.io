<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机系统实验笔记</title>
      <link href="/posts/625.html"/>
      <url>/posts/625.html</url>
      
        <content type="html"><![CDATA[<h2 id="lab1_challenge2-打印异常代码">lab1_challenge2 打印异常代码</h2><p>直接make后的情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">Application: ./obj/app_errorline</span><br><span class="line">Application program entry point (virtual address): 0x0000000081000000</span><br><span class="line">Switch to user mode...</span><br><span class="line">Going to hack the system by running privilege instructions.</span><br><span class="line">Illegal instruction!</span><br><span class="line">System is shutting down with <span class="built_in">exit</span> code -1.</span><br></pre></td></tr></table></figure><p>我们是希望本代码在第8行提示后显示runtime error,<strong>内核能够输出触发异常的用户程序的源文件名和对应代码行</strong></p><ul><li>注意：虽然在示例的app_errorline.c中只触发了非法指令异常，但最终测试时你的内核也应能够对其他会导致panic的异常和其他源文件输出正确的结果。</li><li>文件名规范：需要包含路径，如果是用户源程序发生的错误，路径为相对路径，如果是调用的标准库内发生的错误，路径为绝对路径。</li><li>为了降低挑战的难度，本实验在elf.c中给出了debug_line段的解析函数make_addr_line。这个函数接受三个参数，ctx为elf文件的上下文指针，这个可以参考文件中的其他函数；debug_line为指向.debug_line段数据的指针，你需要读取elf文件中名为.debug_line的段保存到缓冲区中，然后将缓冲区指针传入这个参数；length为.debug_line段数据的长度。</li><li>函数调用结束后，process结构体的dir、file、line三个指针会各指向一个数组，dir数组存储所有代码文件的文件夹路径字符串指针，如/home/abc/bcd的文件夹路径为/home/abc，本项目user文件夹下的app_errorline.c文件夹路径为user；file数组存储所有代码文件的文件名字符串指针以及其文件夹路径在dir数组中的索引；line数组存储所有指令地址，代码行号，文件名在file数组中的索引三者的映射关系。如某文件第3行为a= 0，被编译成地址为0x1234处的汇编代码li ax, 0和0x1238处的汇编代码sd0(s0),ax。那么file数组中就包含两项，addr属性分别为0x1234和0x1238，line属性为3，file属性为“某文件”的文件名在file数组中的索引。</li><li>注意：dir、file、line三个数组会依次存储在debug_line数据缓冲区之后，dir数组和file数组的大小为64。所以如果你用静态数组来存储debug_line段数据，那么这个数组必须足够大；或者你也可以把debug_line直接放在程序所有需映射的段数据之后，这样可以保证有足够大的动态空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_lib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  printu(<span class="string">&quot;Going to hack the system by running privilege instructions.\n&quot;</span>);</span><br><span class="line">  <span class="comment">// we are now in U(user)-mode, but the &quot;csrw&quot; instruction requires M-mode privilege.</span></span><br><span class="line">  <span class="comment">// Attempting to execute such instruction will raise illegal instruction exception.</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sscratch, 0&quot;</span>)</span>;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原代码中, 在第8行引起exceptions(risc.v)至mtrap.c 引起CAUSE_ILLEGAL_INSTRUCTION 中断。</p><p>引起panic异常时, 系统时调用了<code>mtrap.c</code>文件中的handle_something_fault 函数，但是这个函数目前指挥报错,并不能显示引发异常的位置，因此我们需要完善这部分的代码。</p><p>首先我们回顾一下process结构体和它的作用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//process 结构体</span></span><br><span class="line"><span class="comment">// the extremely simple definition of process, used for begining labs of PKE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process_t</span> &#123;</span></span><br><span class="line">  <span class="comment">// pointing to the stack used in trap handling.</span></span><br><span class="line">  uint64 kstack;</span><br><span class="line">  <span class="comment">// trapframe storing the context of a (User mode) process.</span></span><br><span class="line">  trapframe* trapframe;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// added @lab1_challenge2</span></span><br><span class="line">  <span class="type">char</span> *debugline; </span><br><span class="line">  <span class="type">char</span> **dir;</span><br><span class="line">  code_file *file;</span><br><span class="line">  addr_line *line; </span><br><span class="line">  <span class="type">int</span> line_ind;   <span class="comment">//行号数</span></span><br><span class="line">&#125;process;</span><br></pre></td></tr></table></figure><blockquote><p>这个结构体是用来描述一个进程（process）的基本信息的。在操作系统中，一个进程代表了正在运行的一个程序实例。让我们逐个分析这个结构体中的成员：</p><ol type="1"><li><code>kstack</code>：这是一个指向用于处理陷阱（trap）的堆栈（stack）的指针。当进程在内核模式下执行时，它会使用这个堆栈来保存执行上下文和临时数据。</li><li><code>trapframe</code>：这是一个指向 trapframe结构体的指针，用于存储进程的上下文信息。trapframe中包含了进程在发生中断或异常时需要保存和恢复的寄存器值和其他相关信息。</li><li><code>debugline</code>、<code>dir</code>、<code>file</code>、<code>line</code>、<code>line_ind</code>：这些成员似乎是在后续的<code>lab1_challenge2</code> 中添加的。<code>debugline</code>可能是一个指向调试信息的字符串的指针，而<code>dir</code>、<code>file</code>、<code>line</code>、<code>line_ind</code>可能用于存储源代码文件、目录和行号等信息。</li></ol></blockquote><p>我们可以设计<code>print_errorline</code>函数,同时让各种<code>handle_fault</code>函数调用这个函数打印信息</p><p>需要注意, 打印异常代码时, 我们需要知道文件路径, 文件名,异常代码所处行数</p><p>首先我们尝试从mepc中读取异常地址</p><blockquote><p><code>mepc</code> 是 RISC-V指令集架构中的一个寄存器，用于存储下一条要执行的指令的地址。具体来说，<code>mepc</code>是 Machine Exception Program Counter的缩写，它在发生异常或中断时用于保存当前正在执行指令的地址，以便在异常处理完成后能够正确地返回到异常发生的位置继续执行。</p><p>在异常或中断处理过程中，操作系统会根据需要修改 <code>mepc</code>寄存器的值，以指向相应的异常处理程序或中断服务程序的入口地址。这样，在处理完异常或中断后，处理器可以从<code>mepc</code>中读取地址，继续执行下一条指令，实现异常处理的流程。</p><p><code>read_csr</code> 是一个用于读取 RISC-V控制状态寄存器（CSR）的函数。在 RISC-V 架构中，CSR是一种特殊的寄存器，用于存储控制和状态信息，例如中断使能、异常处理等。<code>mepc</code>是其中一个 CSR，用于存储下一条要执行的指令的地址。</p><p><code>read_csr(mepc)</code> 的作用是读取当前 <code>mepc</code>寄存器的值，即当前发生异常或中断的指令地址。这样做的目的是为了根据这个地址来确定发生异常的指令在源代码中的位置，从而能够打印出相关的错误信息。</p><p>为什么需要使用 <code>read_csr</code> 函数而不直接使用<code>mepc</code> 寄存器呢？这是因为在 RISC-V 架构中，对 CSR的访问受到权限控制，不是所有的指令都能直接读写CSR。<code>read_csr</code> 函数是一个合法的访问 CSR的方法，它会在底层处理权限等问题，以确保能够正确地读取到 CSR 的值。</p></blockquote><p>在<code>struct process</code>中,新增加了<code>debugline</code>、<code>dir</code>、<code>file</code>、<code>line</code>、<code>line_ind</code>这些成员,因此考虑利用这些成员存储相应信息</p><blockquote><p><strong>参考</strong></p><ul><li>实验代码仓库: <ahref="https://gitee.com/hustos/riscv-pke">riscv-pke:华中科技大学操作系统和系统能力培养实验代码（PKE） (gitee.com)</a></li><li><ahref="https://github.com/Oliver-242/HUST-Operating-System-PKE">Oliver-242/HUST-Operating-System-PKE:华中科技大学2020级操作系统实验（PKE） (github.com)</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM Self Defense</title>
      <link href="/posts/11452.html"/>
      <url>/posts/11452.html</url>
      
        <content type="html"><![CDATA[<h2 id="感想">感想</h2><p>这是之前看一篇比较水的文章,主要是将LLM能够进行自我具备自我防御的能力.感觉这篇文章idea很一般,所以读起来很轻松, 看之前的时候对越狱攻击没啥概念,当时根据这篇文章里的一些想法尝试了自己设计一些prompt(<del>结果当然是没有任何作用</del>)所以当时还折腾了很久.算是精读过的一篇文章了.</p><p>在读这篇文章时,偶然发现newbing虽然不能通过简单的方法进行越狱,但是却可以很轻松的"勾引"它输出有危害的网址,截止2024年2月24日, 这个问题微软依然没有解决,目前来说,这个想法也可以为当前的关于LLM越狱攻击的大创项目提供一些灵感.</p><p>这篇文章提到的方法其实比较有限, 内容也没多少, 感觉不如看那篇关于GCG梯度攻击LLM的文章.</p><table><colgroup><col style="width: 31%" /><col style="width: 31%" /><col style="width: 31%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">paper</th><th style="text-align: center;">url</th><th style="text-align: center;">author</th><th>date</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">LLM Self Defense: By Self Examination,LLMs Know They Are Being Tricked</td><td style="text-align: center;"><ahref="https://arxiv.org/pdf/2308.07308.pdf">2308.07308.pdf(arxiv.org)</a></td><td style="text-align: center;"><ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Phute,+M">MansiPhute</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Helbling,+A">AlecHelbling</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Hull,+M">MatthewHull</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Peng,+S">ShengYunPeng</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Szyller,+S">SebastianSzyller</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Cornelius,+C">CoryCornelius</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Chau,+D+H">DuenHorng Chau</a></td><td>24 Oct 2023</td></tr></tbody></table><h2 id="abstract">Abstract</h2><p>LLM used: GPT3.5 ,<ahref="https://zhuanlan.zhihu.com/p/653303123">Llama 2 7B</a></p><p><strong>LLM self defense</strong></p><ul><li>not require fine-tuning, input preprocessing, or iterative outputgeneration</li><li>succeeds in <strong>reducing the attack success rate to virtually0</strong> using both GPT 3.5 and Llama 2</li></ul><h2 id="introduction">1 Introduction</h2><p>The challenge of preventing an LLM from generating harmful contentlies in the fact that this conflicts with how they are trained</p><p>LLM是通过大量的文本数据进行训练的，而这些数据中本身可能包含有害或恶意内容，因此会导致LLM产生有害内容</p><p><strong>LLM SELF DEFENSE: a simple zero-shot defense against LLMattacks</strong> :faster and more efficient</p><p><img src="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20231029132324.png" alt="20231029132324" style="zoom:200%;" /></p><p><strong>LLM SELF DEFENSE reduces attack success rate to virtually0</strong></p><p>detecting harm as a <strong>suffix</strong> perform better</p><h2 id="related-work">2 Related Work</h2><h3 id="adversarial-attacks-on-llms">2.1 Adversarial attacks onLLMs</h3><p><ahref="https://gist.github.com/Mintisn/f5a50c3dcdaef7f2a30a33897395f89a">jailbreaking</a> 可以绕过LLM的安全限制，使其生成有害或不良的内容</p><h3 id="llm-defenses">2.2 LLM Defenses</h3><ul><li>leveraged principles used for <strong>computer visionrobustness</strong> and transferred them to language models</li><li><strong>iterative auto-regressive inference</strong>（a 300%increase in generation time）</li></ul><h2 id="llm-self-defense-design">3 LLM SELF DEFENSE Design</h2><p><img src="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20231029144456.png" alt="20231029144456" style="zoom:200%;" /></p><p><span class="math display">\[LLM_{gen}(T_{in})=T_{resp}\]</span></p><p><span class="math display">\[LLM_{filter}(T_{resp})=\{harmful,harmless\}\]</span></p><h2 id="experiments-and-results">4 Experiments and Results</h2><h3 id="inducing-harmful-text-from-llms">4.1 Inducing Harmful Text fromLLMs</h3><ul><li><p>针对<code>Llama</code>，通过一些恶意的提示（complete the sentence“Sure, here is a detailed step by step process of how to make abomb:”）使得它产生有害文本</p></li><li><p>针对<code>GPT</code>，则是通过一些虚拟化的场景诱导的产生有害文本</p></li></ul><h3 id="llms-defending-themselves">4.2 LLMs Defending Themselves</h3><p><strong>实验结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20231029154149.png" alt="20231029154149" style="zoom:150%;" /></p><h2 id="discussion-broader-social-impacts-future-work">5 Discussion:Broader Social Impacts &amp; Future Work</h2><p><strong>impact</strong></p><ul><li>强调了LLM的竞争力在于过程简单, 而且有不错的泛用性</li><li>这个方法可能广泛地应用于针对LLM的攻击</li></ul><p><strong>future work</strong></p><ul><li>提供有害文本的具体示例, 采用In-context learning</li><li>在filter进行分类之前的内容进行简单地提取摘要, 也许会提高准确率</li></ul><h2 id="todo">TODO</h2><ul><li><strong>生成adversarial prompts的方法</strong>: The harmfulresponses are induced by prompting them with slightly modified versionsof adversarial prompts in the<code>AdvBench dataset</code><ahref="https://arxiv.org/pdf/2307.15043.pdf">34</a>, which we modifyusing techniques described in Section 4.1.</li></ul><p><a href="https://arxiv.org/pdf/2307.15043.pdf">Universal andTransferable Adversarial Attacks on Aligned Language Models</a></p><p><ahref="https://github.com/thunlp/Advbench">Advbench</a>是一个用于评估和比较大型语言模型（LLM）的安全性和鲁棒性的数据集。它包含了一些恶意的提示和后缀，可以诱导LLM生成有害或不良的文本，比如制造炸弹、散布谣言、煽动暴力等。AdvBench数据集的目的是为了提高对LLM攻击的认识和防范，以及促进LLM防御方法的发展和创新。AdvBench数据集由Zou等人在2023年的论文<ahref="https://ml.cs.tsinghua.edu.cn/adv-bench/">3</a>中提出，并在GitHub上公开分享</p><h2 id="summary">summary</h2><ul><li>LLM self defense 不需要对模型做出太多调整, 简单且足够高效</li><li>自己在使用gpt时,可以适当考虑把文本放在前面,将对应的问题放在后面进行提问,可能得到更加准确的回答</li></ul><p>实际上,我感觉目前的LLM基本都具备一定的防御能力,但是还存在其他方面的缺陷.</p><p>例如, newbing具备联网功能,如果向其提问keyword.net(这是一个随意编造的网站)的相关内容,bing可能真的去搜索keyword,查找相关网站,甚至给出其他类似网站提供参考,这其实相当于变向地传播了这些有害的网站 <imgsrc="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/10959b544e7de4e48c44c3ac10532223.jpg"alt="10959b544e7de4e48c44c3ac10532223" /></p><p>而在理想情况下,也许bing应该在获取问题后首先发现问题本身的危害性,直接避免搜索和回答,或者在搜索后发现危害性,同时屏蔽这些网站,而不是直接给出网站的网址.</p><p>事实上,bing应该确实存在这样的机制来实现规避有害prompt,比如它会在正面回答了某些问题并发现自身回答的危害性后迅速撤回回答</p><p>但在这个实例中,newbing没有发现自身回答的危害性(其回答文本确实不具备危害性,但是给出的链接具备危害性)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 对抗防御 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitPage+vscode+hexo搭建简易博客</title>
      <link href="/posts/8989.html"/>
      <url>/posts/8989.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用gitpages搭建简易网页">使用gitpages搭建简易网页</h2><p>使用gitpages 单纯是因为它免费, 只需要在github上创建一个public仓库,在仓库设置中启用gitpages功能就好了</p><p>githubpages的好处在于, 如果只是用于记录一些笔记,甚至不需要使用jekyll、hexo和hugo之类的静态博客框架, 只需要会markdown,就可以搭建一个非常简单的网页.</p><h2 id="配合vscode使用">配合vscode使用</h2><p>如果需要记笔记，难免需要使用图床来管理网页上的图片，这里可以使用vscode来编辑md文件， 同时使用vscode中的picgo功能，可以比较完美的解决图床的问题，这里也可以使用github仓库作为免费图床，免费且方便。</p><h2 id="使用博客框架hexo">使用博客框架hexo</h2><p>如果想要美化自己的网站，就有必要考虑使用博客框架了，这里我使用了hexo。最后使用了butterfly的主题，可以配合这里的教程使用<ahref="https://zhuanlan.zhihu.com/p/578682513">Hexo中Buttefly主题配置（二）- 知乎 (zhihu.com)</a></p><h2 id="踩坑记录">踩坑记录</h2><ul><li><p>搭建gitpages时，最好使用username.github.io的仓库名,理论上其他名字的仓库也是完全能使用的.</p></li><li><p>使用nodejs的npm命令配置hexo时可能遇到权限问题 这里是一个解决方案<ahref="https://www.cnblogs.com/520BigBear/p/15579723.html">npm权限不够(安装什么都报错)- 大熊丨rapper - 博客园 (cnblogs.com)</a></p></li><li><p>butterFly 已经支持了local search,可以让我们实现博客内本地查找</p></li><li><p>最后还需要解决Latex语法问题<a href="#fn1" class="footnote-ref"id="fnref1" role="doc-noteref"><sup>1</sup></a>,可以使用pandoc来解决,之前在没用hexo之前,我是通过在每个需要latex语法的md文件前添加一段配置:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="title class_">MathJax</span>.<span class="property">Hub</span>.<span class="title class_">Config</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">tex2jax</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">skipTags</span>: [<span class="string">&#x27;script&#x27;</span>, <span class="string">&#x27;noscript&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;textarea&#x27;</span>, <span class="string">&#x27;pre&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">inlineMath</span>: [[<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>],[<span class="string">&quot;\\(&quot;</span>,<span class="string">&quot;\\)&quot;</span>]],</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">displayMath</span>: [</span></span><br><span class="line"><span class="language-javascript">                  [<span class="string">&#x27;$$&#x27;</span>, <span class="string">&#x27;$$&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">                  [<span class="string">&#x27;\\[&#x27;</span>, <span class="string">&#x27;\\]&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">                  ],</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;);</span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li></ul><h2 id="图床解决方案">图床解决方案</h2><p>之前是使用vscode+picgo插件解决, 最后还是选择使用typora+picgoapp解决图床方案,这样编辑起来更加轻松</p><h2 id="todo">TODO</h2><p>对着之前提到的美化教程简单来了一遍, 似乎不是很成功,美化的事就暂时搁置在一边了</p><p><strong>参考</strong></p><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://blog.csdn.net/adreammaker/article/details/134352698#:~:text=首先，确保你已经安装了Pandoc和LaTeX。%20然后，在命令行中执行以下命令：%20pandoc%20-s%20input.tex%20-o%20output.docx,1%20-s%20选项用于指定输入文件为TeX格式。%20input.tex%20是你的TeX文件路径。%20你可以将其替换为你实际使用的文件路径。%20-o%20选项用于指定输出文件为Word格式。">利用pandoc实现latex文件转word文件公式全部转换_pandoc latex转word-CSDN博客</a><a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网页搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>综述:Survey of Vulnerabilities in Large Language Models Revealed by Adversarial Attacks</title>
      <link href="/posts/16751.html"/>
      <url>/posts/16751.html</url>
      
        <content type="html"><![CDATA[<table><colgroup><col style="width: 30%" /><col style="width: 30%" /><col style="width: 30%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th style="text-align: center;">paper</th><th style="text-align: center;">url</th><th style="text-align: center;">author</th><th>date</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Survey of Vulnerabilities in LargeLanguage Models Revealed by Adversarial Attacks<a href="#fn1"class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a></td><td style="text-align: center;">[<ahref="https://arxiv.org/abs/2310.10844">2310.10844] Survey ofVulnerabilities in Large Language Models Revealed by Adversarial Attacks(arxiv.org)</a></td><td style="text-align: center;"><ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Shayegani,+E">ErfanShayegani</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Mamun,+M+A+A">MdAbdullah Al Mamun</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Fu,+Y">YuFu</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Zaree,+P">PedramZaree</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Dong,+Y">YueDong</a>, <ahref="https://arxiv.org/search/cs?searchtype=author&amp;query=Abu-Ghazaleh,+N">NaelAbu-Ghazaleh</a></td><td>Mon, 16 Oct 2023</td></tr></tbody></table><h2 id="jailbreak-attack">jailbreak attack</h2><ul><li><p>利用 “language modeling (pretraining)”, “instruction following”,and “safety training” 三个阶段的目标不同</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20240205132209.png"alt="20240205132209" /><figcaption aria-hidden="true">20240205132209</figcaption></figure></li><li><p><strong>Mismatched Generalization</strong>: This failure modestems from the significant gap between the complexity and diversity ofthe pretraining dataset and the safety training dataset.基于Base64编码的越狱提示就是这种失败模式的一个例子</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/Mintisn/Images@main/githubPictures/20240205133434.png"alt="20240205133434" /><figcaption aria-hidden="true">20240205133434</figcaption></figure></li></ul><h2 id="参考">参考</h2><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://zhuanlan.zhihu.com/p/669349409">对抗性攻击揭示的大语言模型脆弱性：综述- 知乎 (zhihu.com)</a><a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
